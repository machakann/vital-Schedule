let s:scope = themis#helper('scope')
let s:Schedule = s:scope.funcs('autoload/vital/__Schedule__/Schedule.vim')

Describe Switch
  Before
    let Switch = s:Schedule.Switch
  End

  Context ._on()/_off()
    It controls the state of switch
      Assert True(Switch()._on()._isactive())
      Assert False(Switch()._off()._isactive())
      Assert True(Switch()._on()._off()._on()._isactive())
    End
  End

  Context .skip()
    It controls temporal off state of a switch
      let switch = Switch()

      call switch._on().skip(1)
      Assert False(switch._isactive())

      Assert True(switch._skipsthistime())

      Assert True(switch._isactive())
      Assert False(switch._skipsthistime())

      call switch.skip(2)
      Assert False(switch._isactive())

      Assert True(switch._skipsthistime())
      Assert True(switch._skipsthistime())

      Assert True(switch._isactive())
      Assert False(switch._skipsthistime())
    End
  End

  Context .skipif()
    It sets a condition to skip an action
      let switch = Switch()
      call switch._on()
      call switch.skipif({-> g:skip == 1}, [])

      let g:skip = 0
      Assert False(switch._skipsthistime())

      let g:skip = 1
      Assert True(switch._skipsthistime())

      let g:skip = 2
      Assert False(switch._skipsthistime())
    End
  End
End

Describe Counter
  Before
    let Counter = s:Schedule.Counter
  End

  Context .leftcount()
    It returns the left count
      Assert Equals(Counter(2).leftcount(), 2)
      Assert Equals(Counter(3).leftcount(), 3)
      Assert Equals(Counter(1).leftcount(), 1)
      Assert Equals(Counter(-1).leftcount(), -1)
    End
  End

  Context .repeat(count)
    It sets its left count
      Assert Equals(Counter(1).repeat(1).leftcount(), 1)
      Assert Equals(Counter(1).repeat(2).leftcount(), 2)
      Assert Equals(Counter(1).repeat(2).repeat(1).leftcount(), 1)

      let counter = Counter(3)
      call counter._tick() " first
      Assert Equals(counter.leftcount(), 2)

      call counter._tick() " second
      Assert Equals(counter.leftcount(), 1)

      call counter._tick() " third
      Assert Equals(counter.leftcount(), 0)
    End
  End

  Context .hasdone()
    It returns TRUE if the count down has finished
      let counter = Counter(3)
      Assert False(counter.hasdone())

      call counter._tick() " first
      Assert False(counter.hasdone())

      call counter._tick() " second
      Assert False(counter.hasdone())

      call counter._tick() " third
      Assert True(counter.hasdone())


      " never done
      let counter = Counter(-1)
      Assert False(counter.hasdone())

      call counter._tick() " first
      Assert False(counter.hasdone())

      call counter._tick() " second
      Assert False(counter.hasdone())

      call counter._tick() " third
      Assert False(counter.hasdone())
    End
  End

  Context .finishif()
    It sets a condition to finish the task
      let counter = Counter(3)
      Assert False(counter.hasdone())

      call counter.finishif({-> g:finish == 1}, [])
      let g:finish = 1
      Assert True(counter.hasdone())


      let counter = Counter(-1)
      Assert False(counter.hasdone())

      call counter.finishif({-> g:finish == 1}, [])
      let g:finish = 1
      Assert True(counter.hasdone())


      let counter = Counter(3)
      Assert False(counter.hasdone())

      call counter.finishif({-> g:finish == 1}, [])
      let g:finish = 0
      Assert False(counter.hasdone())

      call counter._tick() " first
      Assert False(counter.hasdone())

      call counter._tick() " second
      Assert False(counter.hasdone())

      call counter._tick() " third
      Assert True(counter.hasdone())

      unlet! finish
    End
  End
End

Describe Task
  Before
    let Task = s:Schedule.Task
  End

  Context .call(func, args, ...)
    It registers a function to be called later
      let g:count = 0
      let task = Task()
      call task.call({n -> execute('let g:count += n')}, [1])
      Assert Equals(g:count, 0)

      call task.trigger()
      Assert Equals(g:count, 1)

      call task.call({n -> execute('let g:count += 2*n')}, [1])
      Assert Equals(g:count, 1)

      call task.trigger()
      Assert Equals(g:count, 4)

      unlet! g:count
    End
  End

  Context .execute(cmd)
    It registers a command to be executed later
      let g:count = 0
      let task = Task()
      call task.execute('let g:count += 1')
      Assert Equals(g:count, 0)

      call task.trigger()
      Assert Equals(g:count, 1)

      call task.execute('let g:count += 2')
      Assert Equals(g:count, 1)

      call task.trigger()
      Assert Equals(g:count, 4)

      unlet! g:count
    End
  End

  Context .clear()
    It clears all functions and commands registerd
      let g:count = 0
      let task = Task()
      call task.execute('let g:count += 1')
      call task.trigger()
      call task.execute('let g:count += 2')
      call task.trigger()
      Assert Equals(g:count, 4)

      call task.clear()
      Assert Equals(g:count, 4)
      call task.trigger()
      Assert Equals(g:count, 4)

      unlet! g:count
    End
  End
End

Describe NeatTask
  Before
    let NeatTask = s:Schedule.NeatTask
  End

  Context .trigger()
    It triggers all registered functions and commands
      let g:count = 0
      let neattask = NeatTask()
      call neattask.repeat(-1)

      call neattask.execute('let g:count += 1').trigger()
      Assert Equals(g:count, 1)

      call neattask.execute('let g:count += 2').trigger()
      Assert Equals(g:count, 4)

      unlet! g:count
      call neattask.cancel()
    End

    It is skipped if skipcount is set
      let g:count = 0
      let neattask = NeatTask()
      call neattask.repeat(-1)
      call neattask.execute('let g:count += 1')

      call neattask.trigger()
      Assert Equals(g:count, 1)

      call neattask.skip(1)
      call neattask.trigger()
      Assert Equals(g:count, 1)
      call neattask.trigger()
      Assert Equals(g:count, 2)

      unlet! g:count
      call neattask.cancel()
    End

    It is repeated n-times given by .repeat()
      let g:count = 0
      let neattask = NeatTask()
      call neattask.execute('let g:count += 1')

      call neattask.repeat(1)
      Assert Equals(neattask.leftcount(), 1)
      Assert False(neattask.hasdone())
      call neattask.trigger()
      Assert Equals(neattask.leftcount(), 0)
      Assert True(neattask.hasdone())

      call neattask.repeat(3)
      Assert Equals(neattask.leftcount(), 3)
      Assert False(neattask.hasdone())
      call neattask.trigger() " first
      Assert Equals(neattask.leftcount(), 2)
      Assert False(neattask.hasdone())
      call neattask.trigger() " second
      Assert Equals(neattask.leftcount(), 1)
      Assert False(neattask.hasdone())
      call neattask.trigger() " third
      Assert Equals(neattask.leftcount(), 0)
      Assert True(neattask.hasdone())

      unlet! g:count
      call neattask.cancel()
    End
  End
End

Describe TimerTask
  Before
    let TimerTask = s:Schedule.TimerTask
  End

  Context instance
    It is triggered by a delay time
      let g:count = 0
      let timertask = TimerTask()

      call timertask.execute('let g:count = 1')
      Assert Equals(g:count, 0)

      call timertask.waitfor(100)
      Assert Equals(g:count, 0)

      " To check if the timer is appropriately abandoned later
      let id = timertask._getid()

      sleep 100m
      Assert Equals(g:count, 1)
      Assert True(timertask.hasdone())
      Assert Empty(timer_info(id))

      call timertask.cancel()
    End
  End
End

Describe EventTask
  Before
    let EventTask = s:Schedule.EventTask
  End

  Context instance
    It is triggered by an autocmd event
      augroup vital-Schedule
        autocmd!
      augroup END
      let g:count = 0
      let eventtask = EventTask()

      call eventtask.execute('let g:count += 1').repeat(3).skip(1)

      Assert False(exists('#vital-Schedule#WinEnter'))
      call eventtask.waitfor('WinEnter')
      Assert True(exists('#vital-Schedule#WinEnter'))

      doautocmd <nomodeline> vital-Schedule WinEnter
      Assert Equals(g:count, 0)

      doautocmd <nomodeline> vital-Schedule WinEnter
      Assert Equals(g:count, 1)

      call eventtask._off()
      doautocmd <nomodeline> vital-Schedule WinEnter
      Assert Equals(g:count, 1)

      call eventtask._on()
      doautocmd <nomodeline> vital-Schedule WinEnter
      Assert Equals(g:count, 2)

      doautocmd <nomodeline> vital-Schedule WinEnter
      Assert Equals(g:count, 3)

      doautocmd <nomodeline> vital-Schedule WinEnter
      Assert Equals(g:count, 3)
      Assert False(exists('#vital-Schedule#WinEnter'))

      unlet! g:count
      call eventtask.cancel()
    End

    It is triggered by an User autocmd event
      augroup vital-Schedule
        autocmd!
      augroup END
      let g:count = 0
      let eventtask = EventTask()

      call eventtask.execute('let g:count += 1').repeat(3).skip(1)

      Assert False(exists('#vital-Schedule#User#TestEvent'))
      call eventtask.waitfor(['User', 'TestEvent'])
      Assert True(exists('#vital-Schedule#User#TestEvent'))

      doautocmd <nomodeline> User TestEvent
      Assert Equals(g:count, 0)

      doautocmd <nomodeline> User TestEvent
      Assert Equals(g:count, 1)

      call eventtask._off()
      doautocmd <nomodeline> User TestEvent
      Assert Equals(g:count, 1)

      call eventtask._on()
      doautocmd <nomodeline> User TestEvent
      Assert Equals(g:count, 2)

      doautocmd <nomodeline> User TestEvent
      Assert Equals(g:count, 3)
      Assert False(exists('#vital-Schedule#User#TestEvent'))

      unlet! g:count
      call eventtask.cancel()
    End
  End
End

Describe RaceTask
  Before
    let RaceTask = s:Schedule.RaceTask
  End

  Context instance
    It is triggered by any one of given triggers
      augroup vital-Schedule
        autocmd!
      augroup END
      let g:count = 0
      let racetask = RaceTask()

      call racetask.execute('let g:count += 1').repeat(3).skip(1)

      Assert False(exists('#vital-Schedule#WinEnter'))
      Assert False(exists('#vital-Schedule#WinLeave'))
      call racetask.waitfor(['WinEnter', ['WinLeave', '*'], 100])
      Assert True(exists('#vital-Schedule#WinEnter'))
      Assert True(exists('#vital-Schedule#WinLeave'))

      " To check if the timer is appropriately abandoned later
      let id = racetask._getid()

      doautocmd <nomodeline> vital-Schedule WinEnter
      Assert Equals(g:count, 0)

      doautocmd <nomodeline> vital-Schedule WinLeave
      Assert Equals(g:count, 1)

      call racetask._off()
      doautocmd <nomodeline> vital-Schedule WinEnter
      Assert Equals(g:count, 1)

      call racetask._on()
      doautocmd <nomodeline> vital-Schedule WinEnter
      Assert Equals(g:count, 2)

      sleep 100m
      Assert Equals(g:count, 3)
      Assert True(racetask.hasdone())
      Assert Empty(timer_info(id))

      doautocmd <nomodeline> vital-Schedule WinEnter
      Assert Equals(g:count, 3)
      Assert False(exists('#vital-Schedule#WinEnter'))
      Assert False(exists('#vital-Schedule#WinLeave'))

      unlet! g:count
      call racetask.cancel()
    End
  End
End

Describe TaskChain
  Before
    let TaskChain = s:Schedule.TaskChain
  End

  Context instance
    It is triggered by any one of given triggers
      augroup vital-Schedule
        autocmd!
      augroup END
      let g:count = 0

      let taskchain = TaskChain()
      call taskchain.event('WinEnter')
      call taskchain.event('WinLeave').execute('let g:count += 1')
      call taskchain.timer(100).execute('let g:count += 1')

      Assert False(exists('#vital-Schedule#WinEnter'))
      Assert False(exists('#vital-Schedule#WinLeave'))
      call taskchain.waitfor()
      Assert True(exists('#vital-Schedule#WinEnter'))
      Assert False(exists('#vital-Schedule#WinLeave'))

      sleep 100m
      Assert Equals(g:count, 0)

      doautocmd <nomodeline> vital-Schedule WinEnter
      Assert Equals(g:count, 0)
      Assert False(exists('#vital-Schedule#WinEnter'))
      Assert True(exists('#vital-Schedule#WinLeave'))

      doautocmd <nomodeline> vital-Schedule WinLeave
      Assert Equals(g:count, 1)
      Assert False(exists('#vital-Schedule#WinEnter'))
      Assert False(exists('#vital-Schedule#WinLeave'))

      sleep 100m
      Assert Equals(g:count, 2)

      unlet! g:count
      call taskchain.cancel()
    End
  End
End

" vim:set et ts=2 sw=2 sts=-1:

